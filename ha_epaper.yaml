esphome:
  name: dashboard
  friendly_name: dashboard
  includes:
    - std_includes.h
    - weather_icons.h
    - lunar_phase_icons.h

esp32:
  board: esp32-c3-devkitm-1
  framework:
    type: arduino

# Enable logging
logger:

# Enable Home Assistant API
api:
  encryption:
    key: "jBgx0v+Y9eKiQmYTkS0CnHgtDowNDZqgFU26Z2VTYzM="

ota:
  - platform: esphome
    password: "9f78b53ef21c65d689f7408bb1ebe728"

# -------------------------------------- Keep your code above, change your code below --------------------------------------

globals:
  - id: wifi_status
    type: int
    restore_value: no
    initial_value: "0"
  - id: first_update_done
    type: bool
    restore_value: no
    initial_value: "false"
  - id: max_today_events
    type: int
    initial_value: "5"
  - id: max_future_events
    type: int
    initial_value: "5"

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  on_connect:
    then:
      - lambda: |-
          id(wifi_status) = 1;
  on_disconnect:
    then:
      - lambda: |-
          id(wifi_status) = 0;


captive_portal:

# Here is deep sleep part
deep_sleep:
  id: deep_sleep_1
  run_duration: 1min  # Device wake up and run 60s (enough to pull data and update)
  sleep_duration: 60min  # deep sleep for 1h

script:
  - id: update_display
    then:
      - component.update: my_display

interval:
  # Condition: wifi connected && data retrieved && first time
  - interval: 10s  # Check every second
    then:
      - if:
          condition:
            and:
              - wifi.connected:
              - lambda: "return !id(ha_calendar_event_1).state.empty();"
              - lambda: "return !id(first_update_done);"
          then:
            - lambda: |-
                ESP_LOGD("Display", "Updating Display...");
            - script.execute: update_display  # Refresh immediately
            - lambda: "id(first_update_done) = true;"
  - interval: 59s  # run this command before 1s of run_duration end
    then:
      - logger.log: "Entering deep sleep now..."


image:
  - file: image/wifi.jpg
    type: BINARY
    id: esphome_logo
    resize: 400x240
    invert_alpha: true

# Connect to Home Assistant to get time
time:
  - platform: homeassistant
    id: homeassistant_time

text_sensor:

  - platform: homeassistant
    id: lunar_phase
    entity_id: sensor.moon_phase

  - platform: homeassistant
    id: bin_collection
    entity_id: sensor.bin_collection_sensor

  - platform: homeassistant
    id: ha_calendar_event_1
    entity_id: calendar.calendar
    attribute: "message"

  - platform: homeassistant
    id: ha_calendar_start_time_1
    entity_id: calendar.calendar
    attribute: "start_time"

  - platform: homeassistant
    id: ha_calendar_end_time_1
    entity_id: calendar.calendar
    attribute: "end_time"

  - platform: homeassistant
    id: ha_calendar_event_2
    entity_id: calendar.epaper_event
    attribute: "message"

  - platform: homeassistant
    id: ha_calendar_start_time_2
    entity_id: calendar.epaper_event
    attribute: "start_time"

  - platform: homeassistant
    id: ha_calendar_end_time_2
    entity_id: calendar.epaper_event
    attribute: "end_time"

  - platform: homeassistant
    id: ha_calendar_event_3
    entity_id: calendar.new_calendar
    attribute: "message"

  - platform: homeassistant
    id: ha_calendar_start_time_3
    entity_id: calendar.new_calendar
    attribute: "start_time"

  - platform: homeassistant
    id: ha_calendar_end_time_3
    entity_id: calendar.new_calendar
    attribute: "end_time"

  # New combined calendar sensors
  - platform: homeassistant
    id: combined_calendar_today
    entity_id: sensor.combined_calendar_events
    attribute: "today_events"
    internal: true

  - platform: homeassistant
    id: combined_calendar_future
    entity_id: sensor.combined_calendar_events
    attribute: "future_events"
    internal: true
  - platform: homeassistant
    entity_id: weather.forecast_home
    id: myWeather

  - platform: homeassistant
    entity_id: weather.forecast_home
    id: temp
    attribute: "temperature"

  - platform: homeassistant
    id: temp_unit

    entity_id: weather.forecast_home
    attribute: "temperature_unit"

  - platform: homeassistant
    entity_id: weather.forecast_home
    id: humi

    attribute: "humidity"

  - platform: homeassistant
    entity_id: weather.forecast_home

    id: press
    attribute: "pressure"

  - platform: homeassistant
    id: press_unit
    entity_id: weather.forecast_home
    attribute: "pressure_unit"
    
  - platform: homeassistant
    entity_id: weather.forecast_home
    id: wind
    attribute: "wind_speed"

  - platform: homeassistant
    id: wind_unit
    entity_id: weather.forecast_home
    attribute: "wind_speed_unit"


font:
  - file: 'fonts/materialdesignicons-webfont.ttf'
    id: font_mdi_lunar
    size: 80
    glyphs: &mdi-lunar-glyphs
      - "\U000F0F64" # new_moon
      - "\U000F0F67" # waxing_crescent
      - "\U000F0F61" # first_quarter
      - "\U000F0F68" # waxing_gibbous
      - "\U000F0F62" # full_moon
      - "\U000F0F66" # waning_gibbous
      - "\U000F0F63" # last_quarter
      - "\U000F0F65" # waning_crescent

  - file: "fonts/Montserrat-Black.ttf"
    id: web_font
    size: 20
  - file: "fonts/Montserrat-Black.ttf"
    id: data_font
    size: 26
  - file: "fonts/Montserrat-Black.ttf"
    id: sensor_font
    size: 22
  - file: "fonts/Montserrat-Black.ttf"
    id: small_font
    size: 12

  - file: "gfonts://Inter@700" #
    id: font1
    size: 24

  - file: 'fonts/materialdesignicons-webfont.ttf'
    id: font_mdi_battery
    size: 40
    glyphs: &mdi-battery-glyphs
      - "\U000F0083" # Battery alert (0)
      - "\U000F007A" # Battery 10
      - "\U000F007B" # Battery 20
      - "\U000F007C" # Battery 30
      - "\U000F007D" # Battery 40
      - "\U000F007E" # Battery 50
      - "\U000F007F" # Battery 60
      - "\U000F0080" # Battery 70
      - "\U000F0081" # Battery 80
      - "\U000F0082" # Battery 90
      - "\U000F0079" # Battery 100

  - file: 'fonts/materialdesignicons-webfont.ttf' # Directory to save ttf file
    id: font_mdi_large
    size: 200
    glyphs: &mdi-weather-glyphs # https://pictogrammers.com/library/mdi/
      - "\U000F050F" # Thermometer
      - "\U000F058E" # Humidity
      - "\U000F059D" # Wind speed
      - "\U000F0D60" # Atmospheric pressure
      - "\U000F0590" # Cloudy weather
      - "\U000F0596" # Pouring
      - "\U000F0598" # Snowy
      - "\U000F0599" # Sunny
      - "\U000F0591" # Fog
      - "\U000F0592" # Hail
      - "\U000F067E" # Lightning
      - "\U000F067F" # Lightning-rainy
      - "\U000F0595" # Partly-cloudy
      - "\U000F0597" # Rainy
      - "\U000F0670" # Snowy-rainy
      - "\U000F0594" # Night
      - "\U000F059E" # Windy-variant
      - "\U000F1C78" # Hurricane-outline
    
  - file: 'fonts/materialdesignicons-webfont.ttf'
    id: font_weather # Copy the above icon and change the size to 40
    size: 200
    glyphs: *mdi-weather-glyphs
  - file: 'fonts/materialdesignicons-webfont.ttf'
    id: img_font_sensor # Copy the above icon and change the size to 40
    size: 70
    glyphs: *mdi-weather-glyphs

spi:
  clk_pin: GPIO8
  mosi_pin: GPIO10

display:
  - platform: waveshare_epaper
    id: my_display
    cs_pin: GPIO3
    dc_pin: GPIO5
    busy_pin: 
      number: GPIO4
      inverted: true
    reset_pin: GPIO2
    model: 7.50inv2
    update_interval: 50s
    lambda: |-
      // ==== Wi-Fi Status Section ====
      if (id(wifi_status) == 0)
      {
        it.image(180, 0, id(esphome_logo));
        it.print(230, 300, id(data_font), "WI-FI CONNECTING");
      }
      else
      {
        // ==== Weather Icon Section ====
        std::string weather_string = id(myWeather).state;
        const char* icon = get_weather_icon(weather_string);  

        it.printf(120, 85, id(font_weather), TextAlign::CENTER, "%s", icon);

        // ==== Lunar phase Section
        std::string lunar_phase_state = id(lunar_phase).state;
        const char *moon_phase = get_lunar_phase_icon(lunar_phase_state);

        // Display lunar phase icon at the top right
        it.printf(800, 0, id(font_mdi_lunar), TextAlign::TOP_RIGHT, "%s", moon_phase);
            
        // ==== Date Section ====
        auto time_now = id(homeassistant_time).now();
        time_t time_now_t = time_now.timestamp;
        struct tm *timeinfo = localtime(&time_now_t);

        char date_buf[24];
        char day_buf[16];
        strftime(date_buf, sizeof(date_buf), "%e %B", timeinfo);
        strftime(day_buf, sizeof(day_buf), "%A", timeinfo);

        it.printf(225, 110, id(data_font), TextAlign::BOTTOM_LEFT, "%s", date_buf);
        it.printf(225, 70, id(data_font), TextAlign::BOTTOM_LEFT, "%s", day_buf);

        // Display "last updated" time in bottom right - as this has woken from deep sleep, it's hh:mm of time_now
        it.printf(800, 480, id(small_font), TextAlign::BOTTOM_RIGHT, "Last updated: %02d:%02d", timeinfo->tm_hour, timeinfo->tm_min);

        // ==== Temperature Section ====
        int x = 20, y = 180, w = 180, h = 120, r = 10, thickness = 4;
        it.filled_rectangle(x + r, y, w - 2 * r, thickness); // Top border
        it.filled_rectangle(x + r, y + h - thickness, w - 2 * r, thickness); // Bottom border
        it.filled_rectangle(x, y + r, thickness, h - 2 * r); // Left border
        it.filled_rectangle(x + w - thickness, y + r, thickness, h - 2 * r); // Right border
        it.filled_circle(x + r, y + r, r); // Top-left corner
        it.filled_circle(x + w - r, y + r, r); // Top-right corner
        it.filled_circle(x + r, y + h - r, r); // Bottom-left corner
        it.filled_circle(x + w - r, y + h - r, r); // Bottom-right corner
        it.filled_rectangle(x + thickness, y + thickness, w - 2 * thickness, h - 2 * thickness, COLOR_OFF);
        it.printf(x + 10, y + 10, id(sensor_font), "Temperature");
        it.printf(x + 45, y + 75, id(img_font_sensor), TextAlign::CENTER, "\U000F050F");
        it.printf(x + 75, y + 65, id(data_font), "%s%s", id(temp).state.c_str(), id(temp_unit).state.c_str());

        // ==== Humidity Section ====
        x = 220;
        y = 180;
        it.filled_rectangle(x + r, y, w - 2 * r, thickness);
        it.filled_rectangle(x + r, y + h - thickness, w - 2 * r, thickness);
        it.filled_rectangle(x, y + r, thickness, h - 2 * r);
        it.filled_rectangle(x + w - thickness, y + r, thickness, h - 2 * r);
        it.filled_circle(x + r, y + r, r);
        it.filled_circle(x + w - r, y + r, r);
        it.filled_circle(x + r, y + h - r, r);
        it.filled_circle(x + w - r, y + h - r, r);
        it.filled_rectangle(x + thickness, y + thickness, w - 2 * thickness, h - 2 * thickness, COLOR_OFF);
        it.printf(x + 10, y + 10, id(sensor_font), "Humidity");
        it.printf(x + 45, y + 75, id(img_font_sensor), TextAlign::CENTER, "\U000F058E");
        it.printf(x + 75, y + 65, id(data_font), "%s%%", id(humi).state.c_str());

        // ==== Air Pressure Section ====
        x = 20;
        y = 320;
        it.filled_rectangle(x + r, y, w - 2 * r, thickness);
        it.filled_rectangle(x + r, y + h - thickness, w - 2 * r, thickness);
        it.filled_rectangle(x, y + r, thickness, h - 2 * r);
        it.filled_rectangle(x + w - thickness, y + r, thickness, h - 2 * r);
        it.filled_circle(x + r, y + r, r);
        it.filled_circle(x + w - r, y + r, r);
        it.filled_circle(x + r, y + h - r, r);
        it.filled_circle(x + w - r, y + h - r, r);
        it.filled_rectangle(x + thickness, y + thickness, w - 2 * thickness, h - 2 * thickness, COLOR_OFF);
        it.printf(x + 10, y + 10, id(sensor_font), "Air Pressure");
        it.printf(x + 45, y + 75, id(img_font_sensor), TextAlign::CENTER, "\U000F0D60");
        it.printf(x + 85, y + 50, id(data_font), "%s", id(press).state.c_str());
        it.printf(x + 85, y + 78, id(sensor_font), "%s", id(press_unit).state.c_str());

        // ==== Wind Speed Section ====
        x = 220;
        y = 320;
        it.filled_rectangle(x + r, y, w - 2 * r, thickness);
        it.filled_rectangle(x + r, y + h - thickness, w - 2 * r, thickness);
        it.filled_rectangle(x, y + r, thickness, h - 2 * r);
        it.filled_rectangle(x + w - thickness, y + r, thickness, h - 2 * r);
        it.filled_circle(x + r, y + r, r);
        it.filled_circle(x + w - r, y + r, r);
        it.filled_circle(x + r, y + h - r, r);
        it.filled_circle(x + w - r, y + h - r, r);
        it.filled_rectangle(x + thickness, y + thickness, w - 2 * thickness, h - 2 * thickness, COLOR_OFF);
        it.printf(x + 10, y + 10, id(sensor_font), "Wind Speed");
        it.printf(x + 45, y + 75, id(img_font_sensor), TextAlign::CENTER, "\U000F059D");
        it.printf(x + 85, y + 50, id(data_font), "%s", id(wind).state.c_str());
        it.printf(x + 85, y + 78, id(sensor_font), "%s", id(wind_unit).state.c_str());

        // ==== Calendar Section ====
        it.filled_rectangle(430, 30, 5, 430); // Vertical line
        it.printf(540, 40, id(data_font), "Calendar");

        // =================================================================================
        // ==== Old Calendar Parsing Logic (to be removed later) ====
        // =================================================================================
        // ---- Event Data Structures ----
        struct Event
        {
          std::string message;
          std::string start_time;
          std::string end_time;
          time_t start_timestamp;
        };

        auto parse_time = [](const std::string &time_str) -> time_t
        {
          struct tm timeinfo = {};
          if (strptime(time_str.c_str(), "%Y-%m-%d %H:%M:%S", &timeinfo) == nullptr)
          {
            return 0;  // Invalid time
          }
          return mktime(&timeinfo);
        };

        std::vector<Event> events =
        {
          {id(ha_calendar_event_1).state, id(ha_calendar_start_time_1).state, id(ha_calendar_end_time_1).state, parse_time(id(ha_calendar_start_time_1).state)},
          {id(ha_calendar_event_2).state, id(ha_calendar_start_time_2).state, id(ha_calendar_end_time_2).state, parse_time(id(ha_calendar_start_time_2).state)},
          {id(ha_calendar_event_3).state, id(ha_calendar_start_time_3).state, id(ha_calendar_end_time_3).state, parse_time(id(ha_calendar_start_time_3).state)}
        };

        ESP_LOGD("myCalendar", "Start Time: %s -> %ld", id(ha_calendar_start_time_1).state.c_str(), parse_time(id(ha_calendar_start_time_1).state));
        ESP_LOGD("myCalendar", "Start Time: %s -> %ld", id(ha_calendar_start_time_2).state.c_str(), parse_time(id(ha_calendar_start_time_2).state));
        ESP_LOGD("myCalendar", "Start Time: %s -> %ld", id(ha_calendar_start_time_3).state.c_str(), parse_time(id(ha_calendar_start_time_3).state));

        // ---- Event Filtering and Sorting ----
        events.erase(std::remove_if(events.begin(), events.end(), [](const Event &e)
        {
          return e.start_timestamp == 0;
        }), events.end());

        std::sort(events.begin(), events.end(), [](const Event &a, const Event &b)
        {
          return a.start_timestamp < b.start_timestamp;
        });

        // ---- Bin collection ----
        // Could add this to the start of the events vector so the formatting is easier

        // In case the bin isn't configured
        if (!id(bin_collection).state.empty())
        {
          it.printf(440, 80, id(sensor_font), "%s", id(bin_collection).state.c_str());

          // Format of bin sensor appears to be
          // "grey bin in 1 days"
          std::string bin_name;
          int days(-1);

          std::regex pattern(R"((.+) in (\d+) days?)");
          std::smatch match;
          if (std::regex_match(id(bin_collection).state, match, pattern))
          {
            bin_name = match[1];
            days = std::stoi(match[2]);
          }

          if (days < 2 && days >= 0)
          {
            it.printf(440, 100, id(sensor_font), "%s %s", bin_name.c_str(), (days == 1) ? "tomorrow" : "today");
          }
        }

        // ---- Event Time Formatting ----
        auto format_time = [](std::string time_str) -> std::string
        {
          struct tm timeinfo;
          if (strptime(time_str.c_str(), "%Y-%m-%d %H:%M:%S", &timeinfo) == nullptr)
          {
            return "Invalid";
          }
          char buffer[10];
          strftime(buffer, sizeof(buffer), "%I:%M%p", &timeinfo);
          return std::string(buffer);
        };

        auto format_date = [](const std::string &time_str) -> std::string
        {
          struct tm timeinfo = {};
          if (strptime(time_str.c_str(), "%Y-%m-%d %H:%M:%S", &timeinfo) == nullptr)
          {
            return "Invalid";
          }
          char buffer[6];
          strftime(buffer, sizeof(buffer), "%m-%d", &timeinfo);
          return std::string(buffer);
        };

        // ---- Draw Events ----
        int even_x_start_offset = 460;
        int even_y_start_offset = 80;
        for (const auto &event : events)
        {
          if (even_y_start_offset >= 420)
          {
            break;
          }

          // Detect all-day event: if time part is missing (e.g., "YYYY-MM-DD" only)
          bool all_day = false;
          if (event.start_time.length() == 10 || event.end_time.length() == 10)
          {
            all_day = true;
          }

          std::string formatted_date = format_date(event.start_time);
          std::string formatted_start_time = format_time(event.start_time);
          std::string formatted_end_time = format_time(event.end_time);

          std::string time_range;
          if (all_day)
          {
            time_range = formatted_date + "  All day";
          }
          else
          {
            time_range = formatted_date + "  " + formatted_start_time + " - " + formatted_end_time;
          }
          if ((formatted_start_time == "Invalid" || formatted_end_time == "Invalid") && !all_day)
          {
            time_range.clear();
          }
          it.printf(even_x_start_offset, even_y_start_offset, id(sensor_font), "%s", time_range.c_str());
          even_y_start_offset += 30;
          it.printf(even_x_start_offset, even_y_start_offset, id(sensor_font), "%s", event.message.c_str());
          even_y_start_offset += 40;
        }
      }
